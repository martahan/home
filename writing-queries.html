<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>VyPR - Performance Analysis for Python Programs</title>

    <!-- Bootstrap -->
    <link href="static/css/bootstrap.min.css" rel="stylesheet" />

    <link href="static/css/custom.css" rel="stylesheet" />

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script type="text/javascript" src="static/js/bootstrap.min.js"></script>

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
  	<nav class="navbar navbar">
  	  <div class="container-fluid">
  	    <!-- Brand and toggle get grouped for better mobile display -->
  	    <div class="navbar-header">
          <a class="navbar-brand" href="index.html"><img src="static/images/vypr_logo.jpeg" height="50px" margin-top="-10px" /></a>
        </div>

  	    <!-- nav links -->
  	    <div class="collapse navbar-collapse" id="navbar">
  	      <ul class="nav navbar-nav">
  	        <!--<li><a href="tutorial.html">Tutorial</a></li>-->
            <li><a href="use-vypr.html">Get Started with VyPR</a></li>
            <li><a href="publications.html">Publications</a></li>
            <li><a href="talks.html">Talks</a></li>
            <li><a href="team.html">Team</a></li>
            <li><a href="licence.html">Licence</a></li>
  	      </ul>
  	    </div><!-- /.navbar-collapse -->
  	  </div><!-- /.container-fluid -->
  	</nav>

	<div class="container">
    <nav>
      <ul class="pager">
        <li><a href="use-vypr.html">Getting Started with VyPR</a></li>
        <li><a href="writing-queries.html">Writing Queries</a></li>
        <li><a href="vypr-analysis.html">Getting Started with Offline Analysis</a></li>
        <li><a href="offline-analysis-part-1.html">Offline Analysis - Part 1</a></li>
        <li><a href="offline-analysis-part-2.html">Offline Analysis - Part 2</a></li>
      </ul>
    </nav>
    <h1>Writing Queries for VyPR</h1>
    <p>The general idea of VyPR is that the developer writes queries over specific functions in a Python program.  These queries take the form of properties that should hold at runtime.  VyPR decides at runtime whether these properties are satisfied.  The results of the queries are given in the form of data describing the satisfaction by the program of the properties.</p>
    <p>Queries are written in a central file called <b>VyPR_queries.py</b> in the root of a project's directory structure.  This file is written in Python using VyPR's query building library as such:</p>
<pre>
verification_conf = {
  "package.module" : {
    "class.method" : [
      Forall(
        q = changes('x')
      ).Check(
        lambda q : (
          q.next_call('g').duration()._in([0, 0.1])
        )
      )
    ]# class.method
  }# package.module
}# verification_conf
</pre>
      The structure is explained below.

      <h2>Specifying where to query</h2>

      <p>In order to tell VyPR where to apply instrumentation and subsequently query at runtime, you need to give the path to each function that you want to monitor.</p>
      <p>In the query above, the first level strings tell VyPR which module to look inside and the second level strings tell VyPR which function inside that module.</p>

      <h2>A quick introduction to writing queries</h2>

      <p>In order to write a query, you should:</p>
      <ul>
        <li>Define the property to check.</li>
        <li>Select the points in the program at which the property will be checked.</li>
      </ul>

      <h3>Defining constraints</h3>

      <p>We break down function runs into sequences of states (variables and their values) and operations that take place to transform those values.</p>
      <p>VyPR currently supports writing constraints over variables' values and function calls.  These are treated as <b>objects</b> on which you can call methods to build up constraints.</p>
      <p>Suppose that <b>q</b> holds a <b>state</b>.  Then we can check that the value given to <b>x</b> by <b>q</b> is no more than 1:</p>
      <pre>q('x')._in([0, 1])</pre>
      <p>Currently the only transitions that are supported are function calls.  We can take a call <b>t</b> that corresponds to a function call and check that it lasts for no more than 2 seconds:</p>
      <pre>t.duration()._in([0, 2])</pre>
      <p>Given a variable, say <b>q</b>, you can obtain the <b>earliest state or call in the future</b> based on some criteria, and then use the result like a normal variable:</p>
      <pre>q.next_call('f').duration()._in([0, 1])</pre>
      <p>Given any variable <b>t</b> that represents a call, we can ask for the states at either side with</p>
      <pre>t.input()</pre>
      <p>and</p>
      <pre>t.result()</pre>
      We can then treat these like any other states, for example by measuring the value to which they map a program variable:
      <pre>t.result()('x')</pre>
      Measured quantities can also be compared to each other.  We can compare state, for example to check that a function is not modifying a variable:
      <pre>t.input()('x').equals(t.result()('x'))</pre>
      or to check that the duration of a function call has a certain relation to some state:
      <pre>q.next_call('f').duration().lessThan(q('val'))</pre>
      <p>There are standard propositional operators for you to link predicates on variables.  For example, you can place a constraint on the next call along from the state <b>q</b>, but guarded by a constraint on <b>q</b>:</p>
      <pre>If(q('x')._in([0, 10])).then(
  q.next_call('f').duration()._in([0, 0.5])
)</pre>
      <p>We could combine the <i>if-then</i> construct to write something like</p>
      <pre>If(q.next_call('f').input()('x')._in([0, 10])).then(
  q.next_call('f').duration()._in([0, 0.5])
)</pre>
      <p>which asserts that, for some state held by the variable <b>q</b>, if the value of <i>x</i> immediately before the next call to <i>f</i> is no more than 10, then the next call to <i>f</i> should take no more than 0.5 seconds.</p>

      <h3>Selecting points of interest</h3>

      <p>Once a property is defined, VyPR must be told where in the program to check.  Without this, the variables you use in your property have no meaning.  Suppose that you want to take</p>
      <pre>If(q('x')._in([0, 10])).then(
    q.next_call('f')._in([0, 0.5])
  )</pre>
      <p>and check it whenever <b>x</b> changes (so <b>q</b> holds the state in which <b>x</b> has changed).  You can do this with:</p>
      <pre>Forall(q = changes('x')).\
Check(
  lambda q : 
    If(q('x')._in([0, 10])).then(
      q.next_call('f')._in([0, 0.5])
    )
)</pre>
      <p>The <b>Forall</b> tells VyPR that the property given to <b>Check</b> should be checked whenever <b>x</b> changes at runtime.  Further, each time <b>x</b> changes, the state induced will be bound to the variable <b>q</b>.</p>

      <h3>More complex selection of points of interest</h3>

      <p>Suppose you want to check that, <i>whenever <b>file</b> changes, if <b>file</b> is equal to some string, <b>every future call</b> to <b>write</b> should satisfy some constraint.</i>  Then you can write the query:</p>
    <pre>
Forall(q = changes('file')).\
Forall(t = calls('write', after='q')).\
Check(
  lambda q, t :
    If(q('file').equals('some file name')).then(
      t.duration()._in([0, 1])
    )
)</pre>

    <!--<div class="panel panel-default">
      <div class="panel-heading">Theoretical Aside</div>
      <div class="panel-body">
        <p>CFTL requires specifications to be in Prenex-Normal Form (PNF).  Since CFTL is sufficiently similar to First-Order Logic (FO Logic), we can borrow the result that every FO Logic formula can be rewritten into PNF.</p>
      </div>
    </div>-->

    <h1>Specifics</h1>

    <h2>States</h2>

    <p>For the value to which a state <b>q</b> maps <b>x</b>, you can construct the predicates:</p>
    <pre>q('x').equals(v)
q('x')._in([n, m])
q('x')._in((n, m))</pre>
    <p>Here, <b>v</b> is either a constant or another measurable quantity (see above).</p>
    <p>You can find the next call in time to the function <i>f</i> with:</p>
    <pre>q.next_call('f')</pre>
    <p>and treat the result as a call.</p>

    <h2>Calls</h2>
    <p>For a call <b>t</b>, you can measure the duration with:</p>
    <pre>t.duration()</pre>
    <p>and write predicates on this duration:</p>
    <pre>t.duration()._in([n, m])</pre>
    <p>Durations of calls can be compared to other measurable quantities:</p>
    <pre>t.duration() < v</pre>
    <p>where <b>v</b> is some other measurable quantity.</p>
    <p>Currently arithmetic with measurable quantities with respect to constants is supported in a limited form:</p>
    <pre>t.duration() < v * n</pre>
    <p>where <b>n</b> is some constant of the same type of the measured quantity <b>v</b>.  NB:  here, multiplication must be on the right-hand side.</p>
    <p>The states at either side of a call can be obtained with:</p>
    <pre>t.input(), t.result()</pre>
    which gives a <b>state</b> object like any other.
    <p>The time between two states can be measured with:</p>
    <pre>timeBetween(q1, q2)</pre>
    <p>which can then be subject to a constraint by writing:</p>
    <pre>timeBetween(q1, q2)._in([n, m])</pre>
    <h2>Multiple Constraints</h2>
    <p>You can use boolean operators to combine predicates:</p>
    <pre>land(a1, a2, ..., a_n)
lor(a_1, ..., a_n)
lnot(a)</pre>
    <p>There is syntactic sugar for things like implication, which you can write as:</p>
    <pre>If(a).then(b)</pre>
    <p>You must wrap your final property in a lambda; VyPR will use this at runtime:</p>
    <pre>lambda q1, ..., qn : (...)</pre>
    <h2>Point of Interest Selection</h2>
    <p>You can select points of interest based on states or calls with:</p>
    <pre>q = changes('x')
t = calls('f')</pre>
    <p>If a selection predicate is given after the first one in the list, it must depend on the previous one:</p>
    <pre>Forall(q = changes('x')).Forall(t = calls('f', after='q'))...</pre>
    <p>And the property to check at each point of interest is given by:</p>
    <pre>Forall(q1 = ...). ... .Forall(qn = ...)\
.Check(
  lambda q1, ..., qn :
    (...)
)</pre>
  </div>

  <div class="footer-copyright text-center py-3">
    <p>(C) Copyright 2020 CERN and University of Manchester.</p>
  </div>
  
  </body>
</html>